Detect Cycle in a Graph

Graph:
   0
  / \
 1 - 2

Adjacency:
0 → [1,2]
1 → [0,2]
2 → [0,1]

Step By Step Process:

BFS Process:
  Start BFS from node 0, parent = -1
      visited[0] = true
      Queue = [(0,-1)]
  Pop (0,-1)
      Neighbor 1 not visited → enqueue (1,0)
      Neighbor 2 not visited → enqueue (2,0)
  Pop (1,0)
      Neighbor 0 → parent, ignore
      Neighbor 2 → already visited and not parent → Cycle detected


Code: Java

Example 1:

import java.util.*;

public class CycleDetectionBFS {
    private int vertices;
    private List<List<Integer>> adj;

    public CycleDetectionBFS(int v) {
        this.vertices = v;
        adj = new ArrayList<>();
        for (int i = 0; i < v; i++) {
            adj.add(new ArrayList<>());
        }
    }

    // Add undirected edge
    public void addEdge(int u, int v) {
        adj.get(u).add(v);
        adj.get(v).add(u);
    }

    // BFS to check cycle
    private boolean bfs(int start, boolean[] visited) {
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{start, -1});
        visited[start] = true;

        while (!queue.isEmpty()) {
            int[] pair = queue.poll();
            int node = pair[0];
            int parent = pair[1];

            for (int neighbor : adj.get(node)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.offer(new int[]{neighbor, node});
                }
                else if (neighbor != parent) {
                    // visited and not parent → cycle
                    return true;
                }
            }
        }
        return false;
    }

    public boolean hasCycle() {
        boolean[] visited = new boolean[vertices];
        for (int i = 0; i < vertices; i++) {
            if (!visited[i]) {
                if (bfs(i, visited)) {
                    return true;
                }
            }
        }
        return false;
    }

    // Test
    public static void main(String[] args) {
        CycleDetectionBFS g = new CycleDetectionBFS(4);
        g.addEdge(0, 1);
        g.addEdge(1, 2);
        g.addEdge(2, 0); // creates cycle
        g.addEdge(2, 3);

        if (g.hasCycle()) {
            System.out.println("Graph contains cycle");
        } else {
            System.out.println("Graph does not contain cycle");
        }
    }
}

Time Complexity: O(V + E), Adjacency List takes O(V + E)
Space Complexity: O(V + E), Adjacency List Stores all vertices and edges → O(V + E)

Example 2:

   a
  / \
 b---c
      \
       d
        \
         e

import java.util.*;

public class CycleDetectionOptimized {
    private final Map<Character, List<Character>> graph = new HashMap<>();

    public void addEdge(char u, char v) {
        graph.computeIfAbsent(u, k -> new ArrayList<>()).add(v);
        graph.computeIfAbsent(v, k -> new ArrayList<>()).add(u);
    }

    private boolean dfs(char node, char parent, Set<Character> visited) {
        visited.add(node);
        for (char neighbor : graph.getOrDefault(node, List.of())) {
            if (!visited.contains(neighbor)) {
                if (dfs(neighbor, node, visited)) return true;
            } else if (neighbor != parent) {
                return true;
            }
        }
        return false;
    }

    public boolean hasCycle() {
        Set<Character> visited = new HashSet<>();
        for (char v : graph.keySet()) {
            if (!visited.contains(v)) {
                if (dfs(v, '\0', visited)) return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        CycleDetectionOptimized cd = new CycleDetectionOptimized();
        cd.addEdge('a','b');
        cd.addEdge('b','c');
        cd.addEdge('c','a');
        cd.addEdge('c','d');
        cd.addEdge('d','e');

        System.out.println("Cycle present? " + cd.hasCycle());
    }
}

Time Complexity: O(V + E)
Space Complexity: O(V + E), Stores each edge twice (u→v and v→u), Space = O(V + E)
